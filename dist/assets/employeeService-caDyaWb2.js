class n{constructor(e=window.CONFIG?.apiBase||"/api"){this.apiBase=e,this.cache=new Map,this.loadingStates=new Map}async getAuthHeaders(){try{const{data:{session:e}}=await window.supa.auth.getSession();if(!e?.access_token)throw new Error("No valid session found");return{Authorization:`Bearer ${e.access_token}`,"Content-Type":"application/json"}}catch(e){throw console.error("Error getting auth headers:",e),new Error("Authentication required")}}async fetchEmployees(e=!1){const a=`employees_${e}`,t=this.cache.get(a);if(t&&Date.now()-t.timestamp<300*1e3)return t.data;try{this.setLoadingState("fetchEmployees",!0);const o=await this.getAuthHeaders(),r=new URL(`${this.apiBase}/employees`,window.location.origin);e&&r.searchParams.set("include_archived","1");const s=await fetch(r,{headers:o});if(!s.ok){if(s.status===404)return console.info("Employees API not available (404). Continuing without employees."),[];throw new Error(`Failed to fetch employees: ${s.status} ${s.statusText}`)}const i=(await s.json().catch(()=>({employees:[]}))).employees||[];return this.cache.set(a,{data:i,timestamp:Date.now()}),i}catch(o){throw console.error("Error fetching employees:",o),o}finally{this.setLoadingState("fetchEmployees",!1)}}async createEmployee(e){try{this.setLoadingState("createEmployee",!0);const a=await this.getAuthHeaders(),t=await fetch(`${this.apiBase}/employees`,{method:"POST",headers:a,body:JSON.stringify(e)});if(!t.ok){const r=await t.json().catch(()=>({}));throw new Error(r.error||`Failed to create employee: ${t.status}`)}const o=await t.json();return this.invalidateEmployeeCache(),o.employee}catch(a){throw console.error("Error creating employee:",a),a}finally{this.setLoadingState("createEmployee",!1)}}async updateEmployee(e,a){try{this.setLoadingState("updateEmployee",!0);const t=await this.getAuthHeaders(),o=await fetch(`${this.apiBase}/employees/${e}`,{method:"PUT",headers:t,body:JSON.stringify(a)});if(!o.ok){const s=await o.json().catch(()=>({}));throw new Error(s.error||`Failed to update employee: ${o.status}`)}const r=await o.json();return this.invalidateEmployeeCache(),r.employee}catch(t){throw console.error("Error updating employee:",t),t}finally{this.setLoadingState("updateEmployee",!1)}}async archiveEmployee(e){try{this.setLoadingState("archiveEmployee",!0);const a=await this.getAuthHeaders(),t=await fetch(`${this.apiBase}/employees/${e}`,{method:"DELETE",headers:a});if(!t.ok){const o=await t.json().catch(()=>({}));throw new Error(o.error||`Failed to archive employee: ${t.status}`)}this.invalidateEmployeeCache()}catch(a){throw console.error("Error archiving employee:",a),a}finally{this.setLoadingState("archiveEmployee",!1)}}setLoadingState(e,a){this.loadingStates.set(e,a)}isLoading(e){return this.loadingStates.get(e)||!1}invalidateEmployeeCache(){for(const e of this.cache.keys())e.startsWith("employees_")&&this.cache.delete(e)}clearAllCaches(){this.cache.clear()}}const l=new n;export{n as EmployeeService,l as employeeService};
