// ===== server.js =====
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import { OpenAI } from 'openai';
import { createClient } from '@supabase/supabase-js';

// ---------- path helpers ----------
const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);
const FRONTEND_DIR = path.join(__dirname, '../kalkulator');

// ---------- app & core middleware ----------
const app = express();
app.use(express.static(FRONTEND_DIR)); // serve index.html, css, js, etc.
app.use(cors());
app.use(express.json());

// ---------- third-party clients ----------
const openai   = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// ---------- auth middleware ----------
async function authenticateUser(req, res, next) {
  const auth = req.headers.authorization || '';
  if (!auth.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid Authorization header' });
  }
  const token = auth.slice(7);

  const { data: { user }, error } = await supabase.auth.getUser(token);
  if (error || !user) return res.status(401).json({ error: 'Invalid or expired token' });

  req.user_id = user.id;
  next();
}

// ---------- GPT tool schema ----------
const addShiftSchema = {
  name: 'addShift',
  description: 'Add one work shift',
  parameters: {
    type: 'object',
    properties: {
      shift_date: { type: 'string', description: 'YYYY-MM-DD' },
      start_time: { type: 'string', description: 'HH:mm' },
      end_time:   { type: 'string', description: 'HH:mm' }
    },
    required: ['shift_date', 'start_time', 'end_time']
  }
};
const addSeriesSchema = {
  name: 'addSeries',
  description: 'Add multiple identical shifts over a date range',
  parameters: {
    type: 'object',
    properties: {
      from:  { type: 'string', description: 'First day YYYY-MM-DD' },
      to:    { type: 'string', description: 'Last day YYYY-MM-DD (inclusive)' },
      days:  { type: 'array',  items: { type: 'integer' }, description: 'Weekdays 0-6' },
      start: { type: 'string', description: 'Shift start HH:mm' },
      end:   { type: 'string', description: 'Shift end   HH:mm' }
    },
    required: ['from', 'to', 'days', 'start', 'end']
  }
};

const tools = [
  { type: 'function', function: addShiftSchema },
  { type: 'function', function: addSeriesSchema }
];

// ---------- helpers ----------
function generateSeriesDates(from, to, days) {
  const start = new Date(`${from}T00:00:00Z`);
  const end   = new Date(`${to}T00:00:00Z`);
  const out   = [];

  for (let d = new Date(start); d <= end; d.setUTCDate(d.getUTCDate() + 1)) {
    if (days.includes(d.getUTCDay())) out.push(new Date(d));
  }
  return out;
}
function hoursBetween(start, end) {
  const [sh, sm] = start.split(':').map(Number);
  const [eh, em] = end.split(':').map(Number);
  return ((eh * 60 + em) - (sh * 60 + sm)) / 60;
}

// ---------- /settings ----------
app.get('/settings', authenticateUser, async (req, res) => {
  const { data, error } = await supabase
    .from('user_settings')
    .select('hourly_rate')
    .eq('user_id', req.user_id)
    .single();

  if (error && error.code !== 'PGRST116')           // ignore “no rows”
    return res.status(500).json({ error: 'Failed to fetch settings' });

  res.json({ hourly_rate: data?.hourly_rate ?? 0 });
});

// ---------- /chat ----------
app.post('/chat', authenticateUser, async (req, res) => {
  const { messages } = req.body;

  // First call: Let GPT choose tools
  const completion = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages,
    tools,
    tool_choice: 'auto'
  });

  const choice = completion.choices[0].message;
  const call = choice.tool_calls?.[0];

  if (call) {
    const fnName = call.function.name;
    const args = JSON.parse(call.function.arguments);
    let toolResult = '';

    if (fnName === 'addShift') {
      const { error } = await supabase.from('user_shifts').insert({
        user_id:     req.user_id,
        shift_date:  args.shift_date,
        start_time:  args.start_time,
        end_time:    args.end_time,
        shift_type:  0
      });
      if (error) return res.status(500).json({ error: 'Failed to save shift' });

      const hours = hoursBetween(args.start_time, args.end_time);
      toolResult = `OK: Skift lagret (${hours} timer)`;
    }

    if (fnName === 'addSeries') {
      const dates = generateSeriesDates(args.from, args.to, args.days);
      if (!dates.length) return res.status(400).json({ error: 'No matching dates' });

      const rows = dates.map(d => ({
        user_id:    req.user_id,
        shift_date: d.toISOString().slice(0, 10),
        start_time: args.start,
        end_time:   args.end,
        shift_type: 0
      }));
      const { error } = await supabase.from('user_shifts').insert(rows);
      if (error) return res.status(500).json({ error: 'Failed to save series' });

      const totalHours = hoursBetween(args.start, args.end) * rows.length;
      toolResult = `OK: ${rows.length} skift lagret (${totalHours} timer)`;
    }

    // Add tool result to conversation and get GPT's response
    const messagesWithToolResult = [
      ...messages,
      choice,
      {
        role: 'tool',
        tool_call_id: call.id,
        name: call.function.name,
        content: toolResult
      }
    ];

    // Second call: Let GPT formulate a user-friendly response with error handling
    let assistantMessage;
    try {
      const secondCompletion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: messagesWithToolResult,
        tool_choice: 'none'
      });
      assistantMessage = secondCompletion.choices[0].message.content;
    } catch (error) {
      console.error('Second GPT call failed:', error);
      // Fallback message based on tool result
      if (toolResult.startsWith('OK:')) {
        assistantMessage = 'Skiftet er lagret! 👍';
      } else {
        assistantMessage = 'Operasjonen er utført.';
      }
    }

    // Get updated shift list
    const { data: shifts } = await supabase
      .from('user_shifts')
      .select('*')
      .eq('user_id', req.user_id)
      .order('shift_date');

    res.json({ assistant: assistantMessage, shifts: shifts || [] });
  } else {
    // No tool call - just return GPT's direct response
    const assistantMessage = choice.content || "Jeg forstod ikke kommandoen.";

    const { data: shifts } = await supabase
      .from('user_shifts')
      .select('*')
      .eq('user_id', req.user_id)
      .order('shift_date');

    res.json({ assistant: assistantMessage, shifts: shifts || [] });
  }
});

// ---------- export / run ----------
export default app;

if (import.meta.url === `file://${process.argv[1]}`) {
  app.listen(5173, () =>
    console.log('✔ Server running → http://localhost:5173')
  );
}